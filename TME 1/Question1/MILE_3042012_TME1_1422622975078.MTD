<?xml version="1.0" encoding="UTF-8"?>
<mile>
	<session_info>
		<session_id>
			1422622975078
		</session_id>
		<student_id>
			3042012
		</student_id>
		<assignment>
			TME1
		</assignment>
		<local_path>
			C:\Documents and Settings\Jason Bishop\My Documents\Dropbox\COMP382\TME1\Question1
		</local_path>
	</session_info>
	<session_data>
		<compile_instance>
			<iTime>
				1590500
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10386.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  However,
*   if the offset is made larger, there are visible gaps between the joints of the surfaces.  I believe the value I have used to
*   offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    
    // constructor
    public MyOwn3D() {
        
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        
        su = new SimpleUniverse(c3d);
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        su.addBranchGraph(scene);
    } // end of constructor

    
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class

			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				2206687
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10706.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class

			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				2424687
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				20120.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        Population shapes = new Population();
        objRoot.addChild(shapes.getShapes());
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class


/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:
*   Notes:
*   Classes:
*   Variables:
*
*
*   TEST PLAN
*
*   Normal case:
*   Bad Data case 1 
*   Discussion:
*
*/ 

// import java.applet.Applet;
// import java.awt.*;
// import com.sun.j3d.utils.applet.MainFrame; 
// import com.sun.j3d.utils.universe.*;
// import javax.media.j3d.*;
// import javax.vecmath.*;
// import com.sun.j3d.utils.geometry.*;
// import com.sun.j3d.utils.behaviors.vp.*;
// 
// public class MyOwn3D extends Applet {
//     
//     private BoundingSphere bounds  = new BoundingSphere();   // for environment nodes
//     private SimpleUniverse su;
//     
//     // constructor
//     public MyOwn3D() {
//         
//         setLayout(new BorderLayout());
//         GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
//         Canvas3D c3d = new Canvas3D(config);
//         add("Center", c3d);
//         
//         BranchGroup scene = createSceneGraph();
//         scene.compile();
//         
//         su = new SimpleUniverse(c3d);
//         initUserPosition();        // set user's viewpoint
//         orbitControls(c3d);   // controls for moving the viewpoint
//         su.addBranchGraph(scene);
//     } // end of constructor
// 
//     
//     private BranchGroup createSceneGraph() {
//         
//         BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
//         
//         Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
//         
//         // create the sides and floor
//         TransformGroup floor = makeFace("floor", blue);
//         TransformGroup back = makeFace("back", blue);
//         TransformGroup front = makeFace("front", blue);
//         TransformGroup left = makeFace("left", blue);
//         TransformGroup right = makeFace("right", blue);
//         // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
//         
//         // create lines to divide surfaces into 3x3 grids
//         Shape3D grid = makeGrid();
//         
//         // add children to root branch graph
//         objRoot.addChild(floor);
//         objRoot.addChild(back);
//         objRoot.addChild(left);
//         objRoot.addChild(right);
//         objRoot.addChild(front);
//         // objRoot.addChild(ceiling);
//         objRoot.addChild(grid);
//         
//         Population shapes = new Population();
//         objRoot.addChild(shapes.getShapes());
//         
//         return objRoot;
//     } // end of method
// 
//     // method to create sides and floor of a room
//     private TransformGroup makeFace(String face, Color3f faceColor) {
//         
//         // create standard QuadArray with coordinates for basic surface
//         QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
//         qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
//         qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
//         qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
//         qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
//         
//         // set color for created quad
//         ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
//         Appearance appear = new Appearance();
//         appear.setColoringAttributes(ca);
//         Shape3D shape = new Shape3D(qa, appear);
//         
//         // create ability to transform and translate surface to correct position
//         TransformGroup tg = new TransformGroup();
//         Transform3D t3d = new Transform3D();
//         Transform3D rotate = new Transform3D();
//         
//         // create surface based on input paramaters
//         // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
//         switch (face) {
//             case "floor": t3d.setTranslation(new Vector3f(0f, -15.005f, 0f));
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "ceiling": t3d.rotX(Math.PI);
//                 t3d.setTranslation(new Vector3f(0f, 15.005f, 0f));                
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "left": t3d.rotZ(-Math.PI/2);
//                 t3d.setTranslation(new Vector3f(-15.005f, 0f, 0f));
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "right": t3d.rotZ(Math.PI/2);
//                 t3d.setTranslation(new Vector3f(15.005f, 0f, 0f));
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "front": t3d.rotX(-Math.PI/2);
//                 t3d.setTranslation(new Vector3f(0f, 0f, 15.005f));                
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "back": t3d.rotX(Math.PI/2);
//                 t3d.setTranslation(new Vector3f(0f, 0f, -15.005f));                
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             default: return null;
//         }
//         return tg;
//     } // end of makeFace method
//     
//     // makes lines to divide constructed area into 3x3 grid for each side
//     private Shape3D makeGrid() {
//         
//         // set up initial coordinates for z plane grid lines
//         Point3f[] gridCoords = new Point3f[47];
//         gridCoords[0] = new Point3f(-15f, 15f, 15f);
//         gridCoords[1] = new Point3f(-15f, -15f, 15f);
//         gridCoords[2] = new Point3f(15f, -15f, 15f);
//         gridCoords[3] = new Point3f(15f, 15f, 15f);
//         
//         // create remaining grid lines through z plane
//         Point3f adjust = new Point3f(0, 0, -10);
//         for (int i = 4; i < 16; i++) {
//             gridCoords[i] = new Point3f(gridCoords[i - 4]);
//             gridCoords[i].add(adjust);
//         }
//         
//         // set up initial coordinates for x plane grid lines
//         gridCoords[16] = new Point3f(gridCoords[3]);
//         gridCoords[17] = new Point3f(gridCoords[2]);
//         gridCoords[18] = new Point3f(gridCoords[14]);
//         gridCoords[19] = new Point3f(gridCoords[15]);
//         
//         // create remaining grid lines through x plane
//         adjust = new Point3f(-10, 0, 0);
//         for (int i = 20; i < 32; i++) {
//             gridCoords[i] = new Point3f(gridCoords[i - 4]);
//             gridCoords[i].add(adjust);
//         }
//         
//         // set up initial coordinates for y plane grid lines
//         gridCoords[32] = new Point3f(gridCoords[0]);
//         gridCoords[33] = new Point3f(gridCoords[3]);
//         gridCoords[34] = new Point3f(gridCoords[15]);
//         gridCoords[35] = new Point3f(gridCoords[12]);
//         gridCoords[36] = new Point3f(gridCoords[0]);
//         
//         // create remaining grid lines through y plane
//         adjust = new Point3f(0, -10, 0);
//         for (int i = 37; i < 47; i++) {
//             gridCoords[i] = new Point3f(gridCoords[i - 5]);
//             gridCoords[i].add(adjust);
//         }
//         
//         // create array for vertex counts in LineStripArray
//         int[] lineCounts = new int[11];
//         for (int i = 0; i < lineCounts.length; i++) {
//             if (i < 8) {lineCounts[i] = 4;}
//             else {lineCounts[i] = 5;}
//         }
//         
//         // create LineStripArray object to create lines
//         LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
//         for (int i = 0; i < gridCoords.length; i++) {
//             grid.setCoordinate(i, gridCoords[i]);
//         }
//         
//         return new Shape3D(grid);
//     } // end of makeGrid method
//     
//     private void orbitControls(Canvas3D c)
//     /* OrbitBehaviour allows the user to rotate around the scene, and to
//      zoom in and out.  */
//     {
//         OrbitBehavior orbit = 
//             new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
//         orbit.setSchedulingBounds(bounds);
// 
//         ViewingPlatform vp = su.getViewingPlatform();
//         vp.setViewPlatformBehavior(orbit);      
//     } // end of orbitControls()
// 
//     private void initUserPosition()
//     // Set the user's initial viewpoint using lookAt()
//     {
//         ViewingPlatform vp = su.getViewingPlatform();
//         TransformGroup steerTG = vp.getViewPlatformTransform();
// 
//         Transform3D t3d = new Transform3D();
//         steerTG.getTransform(t3d);
// 
//         // args are: viewer posn, where looking, up direction
//         t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
//         t3d.invert();
// 
//         steerTG.setTransform(t3d);
//     } // end of initUserPosition()
//   
//     public static void main(String args[]) {
//         Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
//     } // end of main
// } // end of class

			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				2820281
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10929.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
        System.out.println("Bounding sphere radius = " + bounds.getRadius());
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        // adds various objects to the scene
        Population shapes = new Population();
        objRoot.addChild(shapes.getShapes());
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				2937906
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10957.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere(new Point3d(0d, 0d, 0d), 10d);
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
        System.out.println("Bounding sphere radius = " + bounds.getRadius());
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        // adds various objects to the scene
        Population shapes = new Population();
        objRoot.addChild(shapes.getShapes());
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				2998578
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10958.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere(new Point3d(0d, 0d, 0d), 100d);
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
        System.out.println("Bounding sphere radius = " + bounds.getRadius());
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        // adds various objects to the scene
        Population shapes = new Population();
        objRoot.addChild(shapes.getShapes());
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				3502562
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10849.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the viewing area.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online.
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        // adds various objects to the scene
        Population shapes = new Population();
        objRoot.addChild(shapes.getShapes());
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				5365984
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9824.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to extend the room from MyOwn3D from question 1 and add various objects to the
*   internal space.
*   
*   Notes: There are 10 objects created as specified in the requirements for question 2.  The planes have had the culling properties
*   removed to be visible at all angles, but the other objects have the default back face culling so the can be seen through when
*   the user moves throughout the environment.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with blue walls and floor with white grid lines as before.  Again the user can move through
*   the environment with mouse controls.  Various objects are placed throughout the scene without overlap.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) The culling and offset issues from question 1 remain the same.
*   
*   2) All objects are not visible from the initial user position, but can be easily seen by manipulating the viewpont via the mouse
*   controls.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        // adds various objects to the scene
        Population shapes = new Population();
        objRoot.addChild(shapes.getShapes());
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				5564078
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				20314.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*          Additionally, the code for creating the simple universe and applet structure have been borrowed from ???.  The methods for
*   orbit controls and initial viewing position have been borrowed from ????.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        //         LoadModel lm = new LoadModel();
        //         objRoot.addChild(lm.getModel());
        LoadModelFixed lmf = new LoadModelFixed();
        objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class


/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:
*   Notes:
*   Classes:
*   Variables:
*
*
*   TEST PLAN
*
*   Normal case:
*   Bad Data case 1 
*   Discussion:
*
*/ 
// 
// import java.applet.Applet;
// import java.awt.*;
// import com.sun.j3d.utils.applet.MainFrame; 
// import com.sun.j3d.utils.universe.*;
// import javax.media.j3d.*;
// import javax.vecmath.*;
// import com.sun.j3d.utils.geometry.*;
// import com.sun.j3d.utils.behaviors.vp.*;
// 
// public class MyOwn3D extends Applet {
//     
//     private BoundingSphere bounds  = new BoundingSphere();   // for environment nodes
//     private SimpleUniverse su;
//     
//     // constructor
//     public MyOwn3D() {
//         
//         setLayout(new BorderLayout());
//         GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
//         Canvas3D c3d = new Canvas3D(config);
//         add("Center", c3d);
//         
//         BranchGroup scene = createSceneGraph();
//         scene.compile();
//         
//         su = new SimpleUniverse(c3d);
//         initUserPosition();        // set user's viewpoint
//         orbitControls(c3d);   // controls for moving the viewpoint
//         su.addBranchGraph(scene);
//     } // end of constructor
// 
//     
//     private BranchGroup createSceneGraph() {
//         
//         BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
//         
//         Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
//         
//         // create the sides and floor
//         TransformGroup floor = makeFace("floor", blue);
//         TransformGroup back = makeFace("back", blue);
//         TransformGroup front = makeFace("front", blue);
//         TransformGroup left = makeFace("left", blue);
//         TransformGroup right = makeFace("right", blue);
//         // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
//         
//         // create lines to divide surfaces into 3x3 grids
//         Shape3D grid = makeGrid();
//         
//         // add children to root branch graph
//         objRoot.addChild(floor);
//         objRoot.addChild(back);
//         objRoot.addChild(left);
//         objRoot.addChild(right);
//         objRoot.addChild(front);
//         // objRoot.addChild(ceiling);
//         objRoot.addChild(grid);
//         
// //         LoadModel lm = new LoadModel();
// //         objRoot.addChild(lm.getModel());
//         LoadModelFixed lmf = new LoadModelFixed();
//         objRoot.addChild(lmf.getModel());
//         
//         return objRoot;
//     } // end of method
// 
//     // method to create sides and floor of a room
//     private TransformGroup makeFace(String face, Color3f faceColor) {
//         
//         // create standard QuadArray with coordinates for basic surface
//         QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
//         qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
//         qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
//         qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
//         qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
//         
//         // set color for created quad
//         ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
//         Appearance appear = new Appearance();
//         appear.setColoringAttributes(ca);
//         Shape3D shape = new Shape3D(qa, appear);
//         
//         // create ability to transform and translate surface to correct position
//         TransformGroup tg = new TransformGroup();
//         Transform3D t3d = new Transform3D();
//         Transform3D rotate = new Transform3D();
//         
//         // create surface based on input paramaters
//         // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
//         switch (face) {
//             case "floor": t3d.setTranslation(new Vector3f(0f, -15.005f, 0f));
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "ceiling": t3d.rotX(Math.PI);
//                 t3d.setTranslation(new Vector3f(0f, 15.005f, 0f));                
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "left": t3d.rotZ(-Math.PI/2);
//                 t3d.setTranslation(new Vector3f(-15.005f, 0f, 0f));
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "right": t3d.rotZ(Math.PI/2);
//                 t3d.setTranslation(new Vector3f(15.005f, 0f, 0f));
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "front": t3d.rotX(-Math.PI/2);
//                 t3d.setTranslation(new Vector3f(0f, 0f, 15.005f));                
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             case "back": t3d.rotX(Math.PI/2);
//                 t3d.setTranslation(new Vector3f(0f, 0f, -15.005f));                
//                 tg.setTransform(t3d);
//                 tg.addChild(shape);
//                 break;
//             default: return null;
//         }
//         return tg;
//     } // end of makeFace method
//     
//     // makes lines to divide constructed area into 3x3 grid for each side
//     private Shape3D makeGrid() {
//         
//         // set up initial coordinates for z plane grid lines
//         Point3f[] gridCoords = new Point3f[47];
//         gridCoords[0] = new Point3f(-15f, 15f, 15f);
//         gridCoords[1] = new Point3f(-15f, -15f, 15f);
//         gridCoords[2] = new Point3f(15f, -15f, 15f);
//         gridCoords[3] = new Point3f(15f, 15f, 15f);
//         
//         // create remaining grid lines through z plane
//         Point3f adjust = new Point3f(0, 0, -10);
//         for (int i = 4; i < 16; i++) {
//             gridCoords[i] = new Point3f(gridCoords[i - 4]);
//             gridCoords[i].add(adjust);
//         }
//         
//         // set up initial coordinates for x plane grid lines
//         gridCoords[16] = new Point3f(gridCoords[3]);
//         gridCoords[17] = new Point3f(gridCoords[2]);
//         gridCoords[18] = new Point3f(gridCoords[14]);
//         gridCoords[19] = new Point3f(gridCoords[15]);
//         
//         // create remaining grid lines through x plane
//         adjust = new Point3f(-10, 0, 0);
//         for (int i = 20; i < 32; i++) {
//             gridCoords[i] = new Point3f(gridCoords[i - 4]);
//             gridCoords[i].add(adjust);
//         }
//         
//         // set up initial coordinates for y plane grid lines
//         gridCoords[32] = new Point3f(gridCoords[0]);
//         gridCoords[33] = new Point3f(gridCoords[3]);
//         gridCoords[34] = new Point3f(gridCoords[15]);
//         gridCoords[35] = new Point3f(gridCoords[12]);
//         gridCoords[36] = new Point3f(gridCoords[0]);
//         
//         // create remaining grid lines through y plane
//         adjust = new Point3f(0, -10, 0);
//         for (int i = 37; i < 47; i++) {
//             gridCoords[i] = new Point3f(gridCoords[i - 5]);
//             gridCoords[i].add(adjust);
//         }
//         
//         // create array for vertex counts in LineStripArray
//         int[] lineCounts = new int[11];
//         for (int i = 0; i < lineCounts.length; i++) {
//             if (i < 8) {lineCounts[i] = 4;}
//             else {lineCounts[i] = 5;}
//         }
//         
//         // create LineStripArray object to create lines
//         LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
//         for (int i = 0; i < gridCoords.length; i++) {
//             grid.setCoordinate(i, gridCoords[i]);
//         }
//         
//         return new Shape3D(grid);
//     } // end of makeGrid method
//     
//     private void orbitControls(Canvas3D c)
//     /* OrbitBehaviour allows the user to rotate around the scene, and to
//      zoom in and out.  */
//     {
//         OrbitBehavior orbit = 
//             new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
//         orbit.setSchedulingBounds(bounds);
// 
//         ViewingPlatform vp = su.getViewingPlatform();
//         vp.setViewPlatformBehavior(orbit);      
//     } // end of orbitControls()
// 
//     private void initUserPosition()
//     // Set the user's initial viewpoint using lookAt()
//     {
//         ViewingPlatform vp = su.getViewingPlatform();
//         TransformGroup steerTG = vp.getViewPlatformTransform();
// 
//         Transform3D t3d = new Transform3D();
//         steerTG.getTransform(t3d);
// 
//         // args are: viewer posn, where looking, up direction
//         t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
//         t3d.invert();
// 
//         steerTG.setTransform(t3d);
//     } // end of initUserPosition()
//   
//     public static void main(String args[]) {
//         Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
//     } // end of main
// } // end of class

			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				175433234
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9535.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 1.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        LoadModel lm = new LoadModel("GUN.3DS");
        objRoot.addChild(lm.getModel());
        //         LoadModelFixed lmf = new LoadModelFixed();
        //         objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				176124968
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9544.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 1.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        //LoadModel lm = new LoadModel("GUN.3DS");
        //objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				FAILED
			<iStatus>
			<iErrLine>
				105
			<iErrLine>
			<iErrMessage>
				cannot find symbol -   method visitNode(javax.media.j3d.Node)
			<iErrMessage>
		</compile_instance>
	</session_data>
			<iStatus>
				FAILED
			<iStatus>
			<iErrLine>
				124
			<iErrLine>
			<iErrMessage>
				cannot find symbol -   method makeBlue(javax.media.j3d.Shape3D)
			<iErrMessage>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				176141343
			</iTime>
			<fName>
				LoadModelFixed.java
			</fName>
			<fSize>
				4884.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:
*   Notes:
*   Classes:
*   Variables:
*
*
*   TEST PLAN
*
*   Normal case:
*   Bad Data case 1 
*   Discussion:
*
*/ 

import ncsa.j3d.loaders.*;
import com.sun.j3d.loaders.Scene;
import java.io.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import java.util.*;

public class LoadModelFixed {
    private Scene loadedScene = null;
    private BranchGroup loadedBG = null;
    private TransformGroup tg = null;
    
    private static final Color3f white = new Color3f(1.0f, 1.0f, 1.0f);
    private static final Color3f black = new Color3f(0.0f, 0.0f, 0.0f);
    private static final Color3f pink = new Color3f(0.97f, 0.6f, 0.98f);
    
    LoadModelFixed(String fileName) {

        // load the model        
        try {
            ModelLoader loader = new ModelLoader();
            loadedScene = loader.load(fileName);
            if(loadedScene != null) {
                // add model to BranchGroup
                loadedBG = loadedScene.getSceneGroup();
            }
        }
        catch( IOException ioe )
        { System.err.println("Could not find file."); }
        
        adjustModel(loadedBG);
        
        Transform3D t3d = new Transform3D();
        t3d.rotX( -Math.PI/2.0 );    // models are often on their face; fix that
        Vector3d scaleVec = calcScaleFactor(loadedBG);   // scale the model
        t3d.setScale( scaleVec );
        tg = new TransformGroup(t3d);
        tg.addChild(loadedBG);
        
    }
    
    private Vector3d calcScaleFactor(BranchGroup loadedBG)
        // Scale the model based on its original bounding box size
    {
        BoundingBox boundbox = new BoundingBox( loadedBG.getBounds() );
        // System.out.println(boundbox);

        // obtain the upper and lower coordinates of the box
        Point3d lower = new Point3d();
        boundbox.getLower( lower );
        Point3d upper = new Point3d();
        boundbox.getUpper( upper );

        // store the largest X, Y, or Z dimension and calculate a scale factor
        double max = 0.0;     
        if( (upper.x - lower.x ) > max ) { max = (upper.x - lower.x ); }

        if( (upper.y - lower.y ) > max ) { max = (upper.y - lower.y ); }

        if( (upper.z - lower.z ) > max ) { max = (upper.z - lower.z ); }

        double scaleFactor = 10.0/max;    // 10 is half the width of the floor
        //System.out.println("max dimension: " + df.format(max) + 
        //                 "; scaleFactor: " + df.format(scaleFactor) );

        // limit the scaling so that a big model isn't scaled too much
        if( scaleFactor < 0.0005 )
            scaleFactor = 0.0005;

        return new Vector3d(scaleFactor, scaleFactor, scaleFactor);
    }   // end of calcScaleFactor()

    // steps through each node in the model to determine if it is an instance of Shape3D
    private void adjustModel(Node node) {
        if(node instanceof Group) {
            Group g = (Group) node;
            Enumeration enumKids = g.getAllChildren();
            while(enumKids.hasMoreElements()) {    // visit children
                SceneGraphObject obj = (SceneGraphObject) enumKids.nextElement();
                if (obj instanceof Node) { adjustModel((Node) obj); }
            }
        }
        else if (node instanceof Shape3D) { makePink((Shape3D) node); }
        }  // end of visitNode()



      private void adjustShape3D(Shape3D shape)
      /* Shape adjusting examples:
            * change the colour of a shape to blue
            * draw the shape in outline (i.e. as a wireframe)
            * make the shape transparent
            * add a texture to the shape (this can be combined with the
              colour changing method)
         The choice of which one depends on adaptNo: 0-3, and
         4 does makeBlue() and addTexture()
      */
      { //switch(adaptNo) {
          makeBlue(shape); 
    //       case 1: drawOutline(shape); break;
    //       case 2: makeAlmostTransparent(shape); break;
    //       case 3: addTexture(shape); break;
    //       case 4: makeBlue(shape); addTexture(shape); break;
    //       default: break;   // say nothing
    //     }
      }  // end of adjustShape3D()
    
      // change the shape's colour to pink
      private void makePink(Shape3D shape) {
          Appearance app = shape.getAppearance();
          Material adjustMat = new Material(black, pink, pink, white, 20.0f);
          app.setMaterial( adjustMat );
          shape.setAppearance(app);
      } // end of makePink()
    
      // return the TransformGroup parent of the adjusted model
      public TransformGroup getModel() { return tg; }
  
} // end of class

			</fData>
			<iStatus>
				FAILED
			<iStatus>
			<iErrLine>
				124
			<iErrLine>
			<iErrMessage>
				cannot find symbol -   method makeBlue(javax.media.j3d.Shape3D)
			<iErrMessage>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				176149640
			</iTime>
			<fName>
				LoadModelFixed.java
			</fName>
			<fSize>
				4887.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:
*   Notes:
*   Classes:
*   Variables:
*
*
*   TEST PLAN
*
*   Normal case:
*   Bad Data case 1 
*   Discussion:
*
*/ 

import ncsa.j3d.loaders.*;
import com.sun.j3d.loaders.Scene;
import java.io.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import java.util.*;

public class LoadModelFixed {
    private Scene loadedScene = null;
    private BranchGroup loadedBG = null;
    private TransformGroup tg = null;
    
    private static final Color3f white = new Color3f(1.0f, 1.0f, 1.0f);
    private static final Color3f black = new Color3f(0.0f, 0.0f, 0.0f);
    private static final Color3f pink = new Color3f(0.97f, 0.6f, 0.98f);
    
    LoadModelFixed(String fileName) {

        // load the model        
        try {
            ModelLoader loader = new ModelLoader();
            loadedScene = loader.load(fileName);
            if(loadedScene != null) {
                // add model to BranchGroup
                loadedBG = loadedScene.getSceneGroup();
            }
        }
        catch( IOException ioe )
        { System.err.println("Could not find file."); }
        
        adjustModel(loadedBG);
        
        Transform3D t3d = new Transform3D();
        t3d.rotX( -Math.PI/2.0 );    // models are often on their face; fix that
        Vector3d scaleVec = calcScaleFactor(loadedBG);   // scale the model
        t3d.setScale( scaleVec );
        tg = new TransformGroup(t3d);
        tg.addChild(loadedBG);
        
    }
    
    private Vector3d calcScaleFactor(BranchGroup loadedBG)
        // Scale the model based on its original bounding box size
    {
        BoundingBox boundbox = new BoundingBox( loadedBG.getBounds() );
        // System.out.println(boundbox);

        // obtain the upper and lower coordinates of the box
        Point3d lower = new Point3d();
        boundbox.getLower( lower );
        Point3d upper = new Point3d();
        boundbox.getUpper( upper );

        // store the largest X, Y, or Z dimension and calculate a scale factor
        double max = 0.0;     
        if( (upper.x - lower.x ) > max ) { max = (upper.x - lower.x ); }

        if( (upper.y - lower.y ) > max ) { max = (upper.y - lower.y ); }

        if( (upper.z - lower.z ) > max ) { max = (upper.z - lower.z ); }

        double scaleFactor = 10.0/max;    // 10 is half the width of the floor
        //System.out.println("max dimension: " + df.format(max) + 
        //                 "; scaleFactor: " + df.format(scaleFactor) );

        // limit the scaling so that a big model isn't scaled too much
        if( scaleFactor < 0.0005 )
            scaleFactor = 0.0005;

        return new Vector3d(scaleFactor, scaleFactor, scaleFactor);
    }   // end of calcScaleFactor()

    // steps through each node in the model to determine if it is an instance of Shape3D
    private void adjustModel(Node node) {
        if(node instanceof Group) {
            Group g = (Group) node;
            Enumeration enumKids = g.getAllChildren();
            while(enumKids.hasMoreElements()) {    // visit children
                SceneGraphObject obj = (SceneGraphObject) enumKids.nextElement();
                if (obj instanceof Node) { adjustModel((Node) obj); }
            }
        }
        else if (node instanceof Shape3D) { makePink((Shape3D) node); }
        }  // end of visitNode()



      private void adjustShape3D(Shape3D shape)
      /* Shape adjusting examples:
            * change the colour of a shape to blue
            * draw the shape in outline (i.e. as a wireframe)
            * make the shape transparent
            * add a texture to the shape (this can be combined with the
              colour changing method)
         The choice of which one depends on adaptNo: 0-3, and
         4 does makeBlue() and addTexture()
      */
      { //switch(adaptNo) {
//           makeBlue(shape); 
    //       case 1: drawOutline(shape); break;
    //       case 2: makeAlmostTransparent(shape); break;
    //       case 3: addTexture(shape); break;
    //       case 4: makeBlue(shape); addTexture(shape); break;
    //       default: break;   // say nothing
    //     }
      }  // end of adjustShape3D()
    
      // change the shape's colour to pink
      private void makePink(Shape3D shape) {
          Appearance app = shape.getAppearance();
          Material adjustMat = new Material(black, pink, pink, white, 20.0f);
          app.setMaterial( adjustMat );
          shape.setAppearance(app);
      } // end of makePink()
    
      // return the TransformGroup parent of the adjusted model
      public TransformGroup getModel() { return tg; }
  
} // end of class

			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				176153531
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9544.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 1.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        //LoadModel lm = new LoadModel("GUN.3DS");
        //objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				176212968
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9545.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 1.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        //LoadModel lm = new LoadModel("GUN.3DS");
        //objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				176816718
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9545.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 1.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        //LoadModel lm = new LoadModel("GUN.3DS");
        //objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				177495328
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9628.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no user input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) Incorrect File Name:  The program will catch the error and display a message: 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        //LoadModel lm = new LoadModel("GUN.3DS");
        //objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				177526656
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9628.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no user input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) Incorrect File Name:  The program will catch the error and display a message: 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        LoadModel lm = new LoadModel("GUN.3DS");
        objRoot.addChild(lm.getModel());
        //         LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
        //         objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				177763906
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9748.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no user input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1)
*   
*   2) Incorrect File Name:  The program will catch the error and display the message "File XXX could not be found."  The room
*   structure will be loaded as an empty room without the model. 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
        LoadModel lm = new LoadModel("GUN1.3DS");
        objRoot.addChild(lm.getModel());
        //         LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
        //         objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				177806547
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9748.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: 
*   
*   TEST PLAN
*
*   Normal case: 
*   
*   There is no user input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1)
*   
*   2) Incorrect File Name:  The program will catch the error and display the message "File XXX could not be found."  The room
*   structure will be loaded as an empty room without the model. 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
       // LoadModel lm = new LoadModel("GUN1.3DS");
       // objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				178251359
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10307.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an external model.  The
*   model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: The loaded model without changes is small, coloured black, lying on its side and located at the origin.  The "fixed" 
*   version of the model loads it scaled to the size of the room structure, colored pink, and located in the -y direction from
*   the origin.  The pink colour displayed is the colour when no light hits the object because no lighting is present in this
*   program.
*   
*   TEST PLAN
*
*   Normal case: The grid room structure is displayed with the loaded model with or without changes depending on the version used.
*   
*   There is no user input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) The culling and offset issues from question 1 remain the same.
*   
*   2) Incorrect File Name:  The program will catch the error and display the message "File XXX could not be found."  The room
*   structure will be loaded as an empty room without the model. 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
       // LoadModel lm = new LoadModel("GUN1.3DS");
       // objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				178390343
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				9810.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D room environment loaded with various geometric structures.
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to extend the room from MyOwn3D from question 1 and add various objects to the
*   internal space.
*   
*   Notes: There are 10 objects created as specified in the requirements for question 2.  The planes have had the culling properties
*   removed to be visible at all angles, but the other objects have the default back face culling so the can be seen through when
*   the user moves throughout the environment.
*   
*   TEST PLAN
*
*   Normal case: The scene is created with blue walls and floor with white grid lines as before.  Again the user can move through
*   the environment with mouse controls.  Various objects are placed throughout the scene without overlap.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) The culling and offset issues from question 1 remain the same.
*   
*   2) All objects are not visible from the initial user position, but can be easily seen by manipulating the viewpont via the mouse
*   controls.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        // adds various objects to the scene
        Population shapes = new Population();
        objRoot.addChild(shapes.getShapes());
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				178438468
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10314.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines, a gun model is loaded in the center
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display the room developed in question 1 and load an example external model.
*   The model can be loaded in the default fashion without any changes to positioning or appearance properties, or it can be loaded
*   in a scaled, colored, rotated and translated version.  Switching between the two versions requires commenting in/out the
*   applicable lines of code.
*   
*   Notes: The loaded model without changes is small, coloured black, lying on its side and located at the origin.  The "fixed" 
*   version of the model loads it scaled to the size of the room structure, colored pink, and located in the -y direction from
*   the origin.  The pink colour displayed is the colour when no light hits the object because no lighting is present in this
*   program.
*   
*   TEST PLAN
*
*   Normal case: The grid room structure is displayed with the loaded model with or without changes depending on the version used.
*   
*   There is no user input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) The culling and offset issues from question 1 remain the same.
*   
*   2) Incorrect File Name:  The program will catch the error and display the message "File XXX could not be found."  The room
*   structure will be loaded as an empty room without the model. 
*   
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);

        // load the gun model into the scene (use comments to see each version)
       // LoadModel lm = new LoadModel("GUN1.3DS");
       // objRoot.addChild(lm.getModel());
                 LoadModelFixed lmf = new LoadModelFixed("GUN1.3DS");
                 objRoot.addChild(lmf.getModel());

        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class
			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
	<session_data>
		<compile_instance>
			<iTime>
				178975484
			</iTime>
			<fName>
				MyOwn3D.java
			</fName>
			<fSize>
				10838.0
			</fSize>
			<fData>
/**
*   Title: MyOwn3D.java
*   Description: A 3D environment representing a room with 4 walls and a floor with grid lines
*   Date: December 13, 2014
*   Author: Jason Bishop
*   Student #: 3042012
*   Version: 2.0
*
*
*   DOCUMENTATION
*
*   Program Purpose:  The purpose of this program is to display a four walled room and floor using shapes in Java3D.  The surfaces
*   are displayed with lines to divide them into 3x3 grids.
*   
*   Notes: The back faces of the quadrilaterals that make up the are culled so that the room can be looked into from outside the four
*   walled area.  The corners of the room do not quite meet because they have been offset by a small factor to allow the grid lines
*   to be more visible.
*   Additionally, the code for creating the simple universe and applet structure have been borrowed from HelloJava3da by Dennis J.
*   Bouvier in Getting Started with the Java 3D API.  The methods for orbit controls and initial viewing position have been borrowed
*   from WrapCheckers3D.java by Andrew Davison in Killer Game Programming.
*   
*   
*   TEST PLAN
*
*   Normal case: The scene is created with 4 blue walls and a blue floor forming 5 sides of a standard cube.  There are white grid
*   lines that divide each surface into a 3x3 grid.  The user is able to move around the environment using the mouse controls.  The
*   objects will disappear when moving outside the bounding sphere.
*   
*   There is no input data to test against, but there are other issues that can be discussed:
*   
*   Bad Data:  
*   
*   1) I ran into a problem with my laptop computer when zooming out too far: the mouse controls stopped working.  However,
*   when tested on another machine there were no issues.  Perhaps this is a limitation of my laptop, or there is some other issue
*   with the way I have written the code, but I can't seem to fix it with the knowledge from this course or from what I tried to
*   research online
*   
*   2) Even though the surfaces are offset by a small degree, there is still some visible stitching with the grid lines.  This is
*   mostly visible at distances far from the viewer.  When moving closer the effect is much less noticable.  However, the offset
*   has not been made larger because this will create visible gaps between the joints of the surfaces.  I believe the value I have
*   used to offset each surface is a good balance between viewing the grid lines and making the room seem like one structure.
*
*/ 

import java.applet.Applet;
import java.awt.*;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.behaviors.vp.*;

public class MyOwn3D extends Applet {
    
    private BoundingSphere bounds  = new BoundingSphere();
    private SimpleUniverse su;
    private static final Color3f blue = new Color3f(0.0f, 0.1f, 0.4f);  // solid color blue for coloring sides and floor
    
    // constructor
    public MyOwn3D() {
        // sets standard configurations for the applet basis of the scene graph
        setLayout(new BorderLayout());
        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
        Canvas3D c3d = new Canvas3D(config);
        add("Center", c3d);
        
        BranchGroup scene = createSceneGraph();
        scene.compile();
        su = new SimpleUniverse(c3d);
        
        initUserPosition();        // set user's viewpoint
        orbitControls(c3d);   // controls for moving the viewpoint
        
        su.addBranchGraph(scene);  // add the content branch graph to the scene
    } // end of constructor

    // creates the content branch of the scene graph
    private BranchGroup createSceneGraph() {
        
        BranchGroup objRoot = new BranchGroup();  // root of visual objects in scene graph
        
        // create the sides and floor
        TransformGroup floor = makeFace("floor", blue);
        TransformGroup back = makeFace("back", blue);
        TransformGroup front = makeFace("front", blue);
        TransformGroup left = makeFace("left", blue);
        TransformGroup right = makeFace("right", blue);
        // TransformGroup ceiling = makeFace("ceiling", new Color3f(1.0f, 1.0f, 1.0f));  // white
        
        // create lines to divide surfaces into 3x3 grids
        Shape3D grid = makeGrid();
        
        // add children to root branch graph
        objRoot.addChild(floor);
        objRoot.addChild(back);
        objRoot.addChild(left);
        objRoot.addChild(right);
        objRoot.addChild(front);
        // objRoot.addChild(ceiling);
        objRoot.addChild(grid);
        
        return objRoot;
    } // end of method

    // method to create sides and floor of a room
    private TransformGroup makeFace(String face, Color3f faceColor) {
        
        // create standard QuadArray with coordinates for basic square surface
        QuadArray qa = new QuadArray(4, QuadArray.COORDINATES);
        qa.setCoordinate(0, new Point3f(-15f, 0f, 15f));
        qa.setCoordinate(1, new Point3f(15f, 0f, 15f));
        qa.setCoordinate(2, new Point3f(15f, 0f, -15f));
        qa.setCoordinate(3, new Point3f(-15f, 0f, -15f));
        
        // set appearance for created quad
        ColoringAttributes ca = new ColoringAttributes(faceColor, 1);
        Appearance appear = new Appearance();
        appear.setColoringAttributes(ca);
        Shape3D shape = new Shape3D(qa, appear);
        
        // create ability to transform and translate surface to correct position
        TransformGroup tg = new TransformGroup();
        Transform3D t3d = new Transform3D();
        Transform3D rotate = new Transform3D();
        
        // translate quad based on input paramaters
        // surfaces are off by a factor of 0.005 to allow grid lines to be more visible
        switch (face) {
            case "floor": t3d.setTranslation(new Vector3f(0f, -15.007f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            // case "ceiling": t3d.rotX(Math.PI);
            //     t3d.setTranslation(new Vector3f(0f, 15.007f, 0f));                
            //     tg.setTransform(t3d);
            //     tg.addChild(shape);
            //     break;
            case "left": t3d.rotZ(-Math.PI/2);
                t3d.setTranslation(new Vector3f(-15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "right": t3d.rotZ(Math.PI/2);
                t3d.setTranslation(new Vector3f(15.007f, 0f, 0f));
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "front": t3d.rotX(-Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, 15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            case "back": t3d.rotX(Math.PI/2);
                t3d.setTranslation(new Vector3f(0f, 0f, -15.007f));                
                tg.setTransform(t3d);
                tg.addChild(shape);
                break;
            default: return null;
        }
        return tg;
    } // end of makeFace method
    
    // makes lines to divide constructed area into 3x3 grid for each side
    private Shape3D makeGrid() {
        
        // set up initial coordinates for z plane grid lines
        Point3f[] gridCoords = new Point3f[47];
        gridCoords[0] = new Point3f(-15f, 15f, 15f);
        gridCoords[1] = new Point3f(-15f, -15f, 15f);
        gridCoords[2] = new Point3f(15f, -15f, 15f);
        gridCoords[3] = new Point3f(15f, 15f, 15f);
        
        // create remaining grid lines through z plane
        Point3f adjust = new Point3f(0, 0, -10);
        for (int i = 4; i < 16; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for x plane grid lines
        gridCoords[16] = new Point3f(gridCoords[3]);
        gridCoords[17] = new Point3f(gridCoords[2]);
        gridCoords[18] = new Point3f(gridCoords[14]);
        gridCoords[19] = new Point3f(gridCoords[15]);
        
        // create remaining grid lines through x plane
        adjust = new Point3f(-10, 0, 0);
        for (int i = 20; i < 32; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 4]);
            gridCoords[i].add(adjust);
        }
        
        // set up initial coordinates for y plane grid lines
        gridCoords[32] = new Point3f(gridCoords[0]);
        gridCoords[33] = new Point3f(gridCoords[3]);
        gridCoords[34] = new Point3f(gridCoords[15]);
        gridCoords[35] = new Point3f(gridCoords[12]);
        gridCoords[36] = new Point3f(gridCoords[0]);
        
        // create remaining grid lines through y plane
        adjust = new Point3f(0, -10, 0);
        for (int i = 37; i < 47; i++) {
            gridCoords[i] = new Point3f(gridCoords[i - 5]);
            gridCoords[i].add(adjust);
        }
        
        // create array for vertex counts in LineStripArray
        int[] lineCounts = new int[11];
        for (int i = 0; i < lineCounts.length; i++) {
            if (i < 8) {lineCounts[i] = 4;}
            else {lineCounts[i] = 5;}
        }
        
        // use LineStripArray to create all lines using points above
        LineStripArray grid = new LineStripArray(47, LineStripArray.COORDINATES, lineCounts);
        for (int i = 0; i < gridCoords.length; i++) {
            grid.setCoordinate(i, gridCoords[i]);
        }
        
        return new Shape3D(grid);
    } // end of makeGrid method
    
    // allows user to use mouse controls to move around the scene
    private void orbitControls(Canvas3D c)
    {
        OrbitBehavior orbit = 
            new OrbitBehavior(c, OrbitBehavior.REVERSE_ALL);
        orbit.setSchedulingBounds(bounds);

        ViewingPlatform vp = su.getViewingPlatform();
        vp.setViewPlatformBehavior(orbit);      
    } // end of orbitControls()
    
    // sets the user's initial position and viewing direction
    private void initUserPosition()
    {
        ViewingPlatform vp = su.getViewingPlatform();
        TransformGroup steerTG = vp.getViewPlatformTransform();

        Transform3D t3d = new Transform3D();
        steerTG.getTransform(t3d);

        // args are: viewer posn, where looking, up direction
        t3d.lookAt( new Point3d(0,5,20), new Point3d(0,0,0), new Vector3d(0,1,0));
        t3d.invert();

        steerTG.setTransform(t3d);
    } // end of initUserPosition()
  
    public static void main(String args[]) {
        Frame frame = new MainFrame(new MyOwn3D(), 256, 256);
    } // end of main
} // end of class

			</fData>
			<iStatus>
				SUCCESS
			<iStatus>
		</compile_instance>
	</session_data>
</mile>
